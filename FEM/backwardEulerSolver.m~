function [temperatureSolutions, heatFluxes, internalEnergy]= backwardEulerSolver(coords, coordsPostProcess, coords, rhs, leftDirichletBoundaryConditionValue, rightDirichletBoundaryConditionValue, k, heatCapacity, timeVector)
% BackwardEulerSolver computes the 1D h-FEM numerical solution of a boundary value problem. 
% Moreover, the numerical solution for each element is also computed
%   coords = coordinates of the mesh points
%   p = vector of degrees of the hierarchical basis. p(i) = maximal degree of the hierarchical basis on the i-th node
%   problem = struct that defines the boundary value problem. The following fields are expected in the struct:
%           LM = Location Map.  LM(i, j) = global unknown index of the j-th unkown local to the i-th element
%           basis_fun = handle to the basis functions
%           B = conductivity matrix
%           F = RHS term
%           M = capacity matrix
%           B_map = correction coefficient to the B function, due to change of variables in the integration
%           F_map = correction coefficient to the F function, due to change of variables in the integration
%           dirichlet_bc = specification of the boundary conditions
%           N = number of elements
%           gdof = number of global degrees of freedom
%   timeVector = vector of time steps for Backward Euler implicit scheme

timeSteps=size(timeVector,2);
timeStepSize=max(timeVector)/( timeSteps );
temperatureSolutions = zeros(size(coordsPostProcess, 2), timeSteps);
heatFluxes = zeros(size(coordsPostProcess, 2), timeSteps);

formatSpec = 'Begin Time Integration Scheme \n' ;
fprintf(formatSpec)

  for t = 1:timeSteps
    
    formatSpec = 'Backward Euler Time Step: %1.1f \n' ;
    fprintf(formatSpec,t)
    
    poissonTransientProblem = poissonProblemTransient(coords, rhs, leftDirichletBoundaryConditionValue, rightDirichletBoundaryConditionValue, k, heatCapacity, t);
    [M, K, f, constrainedTemperatureSolutions] = assemblyAndApplyStrongBCs(problem, temperatureSolutions);
    
    RHS = timeStepSize * (f - K .* assemblyAndApplyStrongBCs);
    LHS = M + timeStepSize * K;
    
    temperatureIncrement = LHS\RHS;
    
  % update temperature
  
    temperatureSolutions = constrainedTemperatureSolutions + temperatureIncrement;
    heatFluxes = evaluateheatFlux( problem, temperatureSolutions );
    internalEnergy = K * temperatureSolutions';
    
  end
  
end






